```
#include <bits/stdc++.h>
using namespace std;


vector<int> grp[101];
int visited[101];
int dis[101][101];
queue<int> q;
vector<int> res;

int v, e;


int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    
    // 입력
    cin >> v >> e;
    
    for (int i=0; i<e; i++)
    {
        int a, b;
        cin >> a >> b;
        grp[a].push_back(b);
        grp[b].push_back(a);
    }
    
    // bfs
    int distance = 1;
    for (int i=1; i<=v; i++)
    {
        q.push(i); visited[i] = 1;
        while(!q.empty())
        {
            int x = q.front(); q.pop();
        
            for (int nx: grp[x])
            {
                if(!visited[nx])
                {
                    q.push(nx); 
                    visited[nx] = 1;
                    dis[nx][x] = distance; dis[x][nx] = distance;
                }
            }
            if (grp[x].empty()) distance--;
            else distance++;
        }
        distance = 1;
        memset(visited, 0, sizeof(visited));
    }
    
    res.resize(v);
    for (int i=1; i<=v; i++)
    {
        for (int j=1; j<=v; j++)
        {
            res[i] += dis[i][j];
        }
    }
    
    int res_index = max_element(res.begin(), res.end()) - res.begin();
    
    cout << res_index;
    
    
    return 0;
}
```

메모리 초과뜸...

```
#include <bits/stdc++.h>
using namespace std;

#define INF 1<<20

int dis[101][101];
vector<int> res;

int v, e;

void lnit(int v)
{
    for (int i=1; i<=v; i++)
    {
        for (int j=1; j<=v; j++)
        { 
            if (i != j) dis[i][j] = INF;
        }
    }
}

void floyd()
{
    for (int k=1; k<=v; k++)
    {
        for (int s=1; s<=v; s++)
        {
            for (int f=1; f<=v; v++) 
               dis[s][f] = min(dis[s][f], dis[s][k] + dis[k][f]);
        }
    }
}

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    
    //무한으로 초기화
    lnit(v);

    // 입력
    cin >> v >> e;
    
    for (int i=0; i<e; i++)
    {
        int a, b;
        cin >> a >> b;
        dis[a][b] = 1; dis[b][a] = 1;
    }
    
    //Floyd
    floyd();
    
    
    //정답 출력
    res.resize(v);
    for (int i=1; i<=v; i++)
    {
        for (int j=1; j<=v; j++)
        {
            if (i != j) res[i] += dis[i][j];
        }
    }
    
    int res_index = max_element(res.begin(), res.end()) - res.begin();
    
    cout << res_index;
    
    
    return 0;
}
```
플로이드 와셜 알고리즘을 사용, 출력이 너무 오래걸리고 출력 자체도 안됨.
