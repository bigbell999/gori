https://yoongrammer.tistory.com/81


```
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
using pll = pair<ll, ll>;

pll jwrl[300002];
ll bag[300002];

ll n, k;
ll size_j = 0;
ll size_b = 0;


//jwrl 관련 함수들.

void enqueue_jwrl(ll weight, ll value)
{
  ll i = 0; 
  
  // 힙 끝에 요소 삽입.
  size_j ++;
  i = size_j;
  jwrl[i] = make_pair(weight, value);
  
  // 보석 가격이 부모 노드가 더 작다면 교환하고 부모 노드부터 다시 비교, 힙속성을 유지할 때까지 반복함.
  while(i > 1 && jwrl[i/2].second < jwrl[i].second) 
  {
    swap(jwrl[i/2], jwrl[i]);
    i = i/2;
  }
}


void heapify_jwrl (ll i)
{
    if (size_j == 0) exit;
    ll largest = i;  
    ll left = 2 * i;            //left child
    ll right = 2 * i + 1;          //right child
  
    // 현재 요소 i와 자식 노드의 값을 비교
    if ( (left <= size_j) && (jwrl[left].second > jwrl[i].second) ) largest = left;  
  
    if ( (right <= size_j) && (jwrl[right].second) > (jwrl[largest].second) ) largest = right;
  
    // 자식 노드의 값이 더 크다면 교환하고 교환된 자식 노드부터 heapify 진행
    if (largest != i ) {
        swap (jwrl[i] , jwrl[largest]);
        heapify_jwrl (largest);
  } 
}


void delete_jwrl()
{
    jwrl[1] = jwrl[size_j];
    size_j--;
    
    heapify_jwrl(1);
}


ll peek_jwrl_weight()
{
    return jwrl[1].first;
}


ll peek_jwrl_value()
{
    return jwrl[1].second;
}



// bag 관련 함수들


void enqueue_bag(ll val)
{
  ll i = 0; 
  
  // 힙 끝에 요소 삽입.
  size_b ++;
  i = size_b;
  bag[i]= val;

  // 가방 무게가 부모 노드가 더 크다면 교환하고 부모 노드부터 다시 비교, 힙속성을 유지할 때까지 반복함.
  while(i > 1 && bag[i/2] > bag[i]) 
  {
    swap(bag[i/2], bag[i]);
    i = i/2;
  }
}


void heapify_bag (ll i)
{
    if (size_b == 0) exit;
    ll smallest = i;  
    ll left = 2 * i;              //left child
    ll right = 2 * i + 1;          //right child
  
    // 현재 요소 i와 자식 노드의 값을 비교
    if(left <= size_b && bag[left] < bag[i] ) smallest = left;  
    if(right <= size_b && bag[right] < bag[smallest] ) smallest = right;        
  
    // 자식 노드의 값이 더 작다면 교환하고 교환된 자식 노드부터 heapify 진행
    if(smallest != i ) 
    {
        swap (bag[i], bag[smallest]);
        heapify_bag (smallest);
    } 
}


void delete_bag (ll num)
{
    bag[num] = bag[size_b];
    size_b--;
    
    heapify_bag(num);
}



void init()
{
    cin >> n >> k;
    
    // 보석을 가격을 priority로 enqueue.
    for (int i=1; i<=n; i++)
    {
        ll weight, value;
        cin >> weight >> value;
        enqueue_jwrl(weight, value);
        
    }
    
    // 가방을 무게를 priority, 내림차순으로 enqueue.
    for (int i=1; i <= k; i++)
    {
        ll weight;
        cin >> weight;
        enqueue_bag(weight);
    }
}


ll solve()
{
    ll res = 0;
    while (size_j != 0)
    {
        ll value = peek_jwrl_value();
        ll weight = peek_jwrl_weight();
        delete_jwrl ();
        
        ll idx = lower_bound (bag, bag + size_b + 1, weight) - bag;
        if (idx <= size_b+1)
        {
            res += value;
            delete_bag(idx);
        }
    }
    
    return res;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    init();

    cout << solve();
  
    return 0;
}
```
