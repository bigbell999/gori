https://yoongrammer.tistory.com/81


```
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
using pll = pair<ll, ll>;

pll jwrl[300002];
ll bag[300002];

ll n, k;
ll size_j = 0;
ll size_b = 0;


void enqueue_jwrl(pll arr[], ll weight, ll value)
{
  ll i = 0; 
  
  // 힙 끝에 요소 삽입.
  size_j ++;
  i = size_j;
  arr[i].first= weight;
  arr[i].second = value;

  // 우선순위가 부모 노드가 더 작다면 교환하고 부모 노드부터 다시 비교, 힙속성을 유지할 때까지 반복함.
  while(i > 1 && arr[i/2].second < arr[i].second) 
  {
    swap(arr[i/2], arr[i]);
    i = i/2;
  }
}


void enqueue_bag(ll arr[], ll val)
{
  ll i = 0; 
  
  // 힙 끝에 요소 삽입.
  size_b ++;
  i = size_b;
  arr[i]= val;

  // 우선순위가 부모 노드가 더 크다면 교환하고 부모 노드부터 다시 비교, 힙속성을 유지할 때까지 반복함.
  while(i > 1 && arr[i/2] > arr[i]) 
  {
    swap(arr[i/2], arr[i]);
    i = i/2;
  }
}


void heapify_jwrl (pll arr[], ll i)
{
  int largest = i;  
  int left = 2*i              //left child
  int right = 2*i +1          //right child
  
  // 현재 요소 i와 자식 노드의 값을 비교
  if(left <= size_j && arr[left].second > arr[i].second )
    largest = left;  
  if(right <= size_j && arr[right].second > arr[largest].second )
    largest = right;
  
  // 자식 노드의 값이 더 크다면 교환하고 교환된 자식 노드부터 heapify 진행
  if(largest != i ) {
    swap (arr[i] , arr[largest]);
    heapify_jwrl (arr, largest);
  } 
}


void heapify_bag (ll arr[], ll i)
{
  int smallest = i;  
  int left = 2*i              //left child
  int right = 2*i +1          //right child
  
  // 현재 요소 i와 자식 노드의 값을 비교
  if(left <= size_b && arr[left] < arr[i] )
    smallest = left;  
  if(right <= size_b && arr[right] < arr[smallest] )
    smallest = right;
  
  // 자식 노드의 값이 더 작다면 교환하고 교환된 자식 노드부터 heapify 진행
  if(smallest != i ) {
    swap (arr[i] , arr[smallest]);
    heapify_bag (arr, smallest);
  } 
}

ll extract_jwrl(ll arr[])
{
    if (size_j == 0) return -1;
    ll max = arr[1];
    arr[1] = arr[size_j];
    size_j--;
    
    heapify_jwrl(arr, 1);
    
    return max;
}

ll extract_bag(ll arr[])
{
    if (size_b == 0) return -1;
    ll min = arr[1];
    arr[1] = arr[size_b];
    size_b--;
    
    heapify_bag(arr, 1);
    
    return min;
}


void init()
{
    cin >> n >> k;
    // 보석을 가격을 priority로 enqueue.
    for (int i=1; i<=n; i++)
    {
        ll weight, value;
        cin >> weight >> value;
        enqueueJwrl(jwrl, weight, value);
        
    }
    // 가방을 무게 내림차순으로 enqueue.
    for (int i=1; i<=k; i++)
    {
        ll weight;
        cin >> weight;
        enqueueBag(bag, weight);
    }
}


ll solve()
{
    ll res = 0;
    for (int i=0; i<n; i++)
    {
        res += extract_j(jwrl)
    }
    
    return res;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    init();
    
    cout << solve();
  
    return 0;
}
```
